package netem

//
// Deep packet inspection
//

import (
	"sync"
	"time"

	"github.com/google/gopacket/layers"
)

// DPIDirection is the direction of packets within a
// flow according to the [DPIEngine].
type DPIDirection int

// DPIDirectionClientToServer is the direction from the
// client to the server. The client is the endpoint that
// sends the first packet in a flow.
const DPIDirectionClientToServer = DPIDirection(0)

// DPIDirectionServerToClient is the direction from the
// server to the client. The client is the endpoint that
// sends the first packet in a flow.
const DPIDirectionServerToClient = DPIDirection(1)

// DPIVerdict is the verdict generated by a [DPIRule].
type DPIVerdict int

// DPIVerdictAccept means the [DPIEngine] should
// accept and forward the packet.
const DPIVerdictAccept = DPIVerdict(0)

const (
	// DPIVerdictDrop means the [DPIEngine] should drop a packet.
	DPIVerdictDrop = DPIVerdict(1 << iota)

	// DPIVerdictThrottle means [DPIEngine] should throttle a packet.
	DPIVerdictThrottle

	// DPIVerdictInject means [DPIEngine] should inject a packet
	// in the opposite direction (usually a RST segment).
	DPIVerdictInject
)

// DPIPolicy tells the [DPIEngine] which policy to apply to a packet.
type DPIPolicy struct {
	// Inject is a packet to inject in the opposite direction.
	Inject []byte

	// PLR is the extra PLR to add to the packet, which is only
	// meaningful with DPIVerdictThrottle.
	PLR float64

	// Verdict is the verdict.
	Verdict DPIVerdict
}

// DPIRule is a deep packet inspection rule.
type DPIRule interface {
	Apply(direction DPIDirection, packet *DissectedPacket) *DPIPolicy
}

// DPIEngine is a deep packet inspection engine. The zero
// value is invalid; construct using [NewDPIEngine].
type DPIEngine struct {
	// logger is the logger.
	logger Logger

	// mu provides mutual exclusion.
	mu sync.Mutex

	// rules contains the rules.
	rules []DPIRule
}

// NewDPIEngine creates a new [DPIEngine] instance.
func NewDPIEngine(logger Logger) *DPIEngine {
	return &DPIEngine{
		logger: logger,
		mu:     sync.Mutex{},
		rules:  nil,
	}
}

var _ LinkNICWrapper = &DPIEngine{}

// AddRule adds a [DPIRule] to the [DPIEngine].
func (de *DPIEngine) AddRule(rule DPIRule) {
	defer de.mu.Unlock()
	de.mu.Lock()
	de.rules = append(de.rules, rule)
}

// getRules returns a copy of the rules.
func (de *DPIEngine) getRules() []DPIRule {
	defer de.mu.Unlock()
	de.mu.Lock()
	return append([]DPIRule{}, de.rules...) // copy
}

// WrapNIC implements LinkNICWrapper
func (de *DPIEngine) WrapNIC(nic NIC) NIC {
	return newDPINIC(de, nic)
}

// dpiNIC is a NIC that implements deep packet inspection. The zero
// value is invalid; construct using [newDPINIC].
type dpiNIC struct {
	// engine is the DPI engine.
	engine *DPIEngine

	// flows contains information about flows.
	flows map[uint64]*dpiFlow

	// logger is the logger.
	logger Logger

	// mu provides mutual exclusion.
	mu sync.Mutex

	// underlying is the underlying NIC.
	underlying NIC
}

// newDPINIC creates a new [dpiNIC] instance.
func newDPINIC(engine *DPIEngine, nic NIC) *dpiNIC {
	return &dpiNIC{
		engine:     engine,
		flows:      map[uint64]*dpiFlow{},
		logger:     engine.logger,
		mu:         sync.Mutex{},
		underlying: nic,
	}
}

var _ NIC = &dpiNIC{}

// FrameAvailable implements NIC
func (dn *dpiNIC) FrameAvailable() <-chan any {
	return dn.underlying.FrameAvailable()
}

// ReadFrameNonblocking implements NIC
func (dn *dpiNIC) ReadFrameNonblocking() (*Frame, error) {
	frame, err := dn.underlying.ReadFrameNonblocking()
	if err != nil {
		return nil, err
	}
	if err := dn.inspectAndFilter(frame); err != nil {
		return nil, err
	}
	return frame, nil
}

// StackClosed implements NIC
func (dn *dpiNIC) StackClosed() <-chan any {
	return dn.underlying.StackClosed()
}

// Close implements NIC
func (dn *dpiNIC) Close() error {
	return dn.underlying.Close()
}

// IPAddress implements NIC
func (dn *dpiNIC) IPAddress() string {
	return dn.underlying.IPAddress()
}

// InterfaceName implements NIC
func (dn *dpiNIC) InterfaceName() string {
	return dn.underlying.InterfaceName()
}

// WriteFrame implements NIC
func (dn *dpiNIC) WriteFrame(frame *Frame) error {
	if err := dn.inspectAndFilter(frame); err != nil {
		return err
	}
	return dn.underlying.WriteFrame(frame)
}

// inspectAndFilter applies DPI to a frame. This function MUTATES the frame
// when the DPI verdict is such that we need to change the PLR.
func (dn *dpiNIC) inspectAndFilter(frame *Frame) error {
	policy := dn.inspect(frame.Payload)

	// a throttling policy causes us to MUTATE the frame's own PLR.
	if policy.Verdict&DPIVerdictThrottle != 0 {
		frame.PLR += policy.PLR
	}

	// packet injection usually deals with sending RST segments
	if policy.Verdict&DPIVerdictInject != 0 {
		frame := &Frame{
			Deadline: time.Now(),
			PLR:      0,
			Payload:  policy.Inject,
		}
		_ = dn.underlying.WriteFrame(frame)
	}

	// the same policy could call for injecting and dropping packets
	// so the check for the drop case should be the last one
	if policy.Verdict&DPIVerdictDrop != 0 {
		return ErrPacketDropped
	}

	return nil
}

// inspect applies DPI to an IP packet.
func (dn *dpiNIC) inspect(rawPacket []byte) *DPIPolicy {
	// dissect the packet and drop packets we don't recognize.
	packet, err := DissectPacket(rawPacket)
	if err != nil {
		return &DPIPolicy{Verdict: DPIVerdictDrop}
	}

	// obtain flow
	flow := dn.getflow(packet)

	// lock the flow record while we're processing it
	defer flow.mu.Unlock()
	flow.mu.Lock()

	// increment number of seen packets
	flow.numPackets++

	// if we have already computed a policy, make sure we are not
	// going to inject packets more than once.
	if flow.policy != nil {
		flow.policy.Verdict &= ^DPIVerdictInject
		return flow.policy
	}

	// avoid inspecting too many flow packets
	const maxPackets = 10
	if flow.numPackets >= maxPackets {
		return &DPIPolicy{Verdict: DPIVerdictAccept}
	}

	// compute direction
	direction := flow.directionLocked(packet)

	// execute all the rules and stop at the first non-accept result
	for _, rule := range dn.engine.getRules() {
		policy := rule.Apply(direction, packet)
		if policy.Verdict != DPIVerdictAccept {
			flow.policy = policy // remember the policy
			return policy
		}
	}

	return &DPIPolicy{Verdict: DPIVerdictAccept}
}

// getflow returns the flow associated with this packet.
func (dn *dpiNIC) getflow(packet *DissectedPacket) *dpiFlow {
	defer dn.mu.Unlock()
	dn.mu.Lock()

	// when a flow has not been modified in 30 seconds, we assume that
	// the record is now stale and we create a new record
	const maxSilence = 30 * time.Second
	fh := packet.FlowHash()
	flow := dn.flows[fh]
	if flow == nil || time.Since(flow.updated) > maxSilence {
		flow = newDPIFlow(packet)
		dn.flows[fh] = flow
	}
	flow.updated = time.Now()

	return flow
}

// dpiFlow is a TCP/UDP flow tracked by DPI.
type dpiFlow struct {
	// destIP is the dest IP address.
	destIP string

	// destPort is the dest port.
	destPort uint16

	// mu provides mutual exclusion.
	mu sync.Mutex

	// numPackets is the number of packets we inspected in either direction.
	numPackets int64

	// policy is the policy we previously evaluated or nil.
	policy *DPIPolicy

	// protocol is the protocol used by the flow.
	protocol layers.IPProtocol

	// sourceIP is the source IP address.
	sourceIP string

	// sourcePort is the source port.
	sourcePort uint16

	// updated is the last time this flow was updated.
	updated time.Time
}

// newDPIFlow creates a new [dpiFlow] instance.
func newDPIFlow(packet *DissectedPacket) *dpiFlow {
	return &dpiFlow{
		destIP:     packet.DestinationIPAddress(),
		destPort:   packet.DestinationPort(),
		mu:         sync.Mutex{},
		numPackets: 0,
		policy:     nil,
		protocol:   packet.TransportProtocol(),
		sourceIP:   packet.SourceIPAddress(),
		sourcePort: packet.SourcePort(),
		updated:    time.Now(),
	}
}

// directionLocked returns the flow direction
func (df *dpiFlow) directionLocked(packet *DissectedPacket) DPIDirection {
	if packet.MatchesDestination(df.protocol, df.destIP, df.destPort) {
		return DPIDirectionClientToServer
	}
	return DPIDirectionServerToClient
}
